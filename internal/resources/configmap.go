package resources

import (
	"fmt"
	"strings"

	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	keydbv1alpha1 "github.com/opendi/keydb-operator/api/v1alpha1"
)

// NewConfigMap creates a ConfigMap with KeyDB configuration
func NewConfigMap(keydbCluster *keydbv1alpha1.KeyDBCluster) *corev1.ConfigMap {
	labels := getLabels(keydbCluster)
	config := generateKeyDBConfig(keydbCluster)

	return &corev1.ConfigMap{
		ObjectMeta: metav1.ObjectMeta{
			Name:      fmt.Sprintf("%s-keydb-config", keydbCluster.Name),
			Namespace: keydbCluster.Namespace,
			Labels:    labels,
		},
		Data: map[string]string{
			"keydb.conf": config,
		},
	}
}

func generateKeyDBConfig(keydbCluster *keydbv1alpha1.KeyDBCluster) string {
	var config strings.Builder

	// Basic configuration
	config.WriteString("# KeyDB Configuration\n")
	config.WriteString("# Generated by KeyDB Operator\n\n")

	// Network configuration
	config.WriteString("bind 0.0.0.0\n")
	config.WriteString("port 6379\n")
	config.WriteString("tcp-backlog 511\n")
	config.WriteString("timeout 0\n")
	config.WriteString("tcp-keepalive 300\n\n")

	// General configuration
	config.WriteString("daemonize no\n")
	config.WriteString("supervised no\n")
	config.WriteString("pidfile /var/run/keydb.pid\n")
	config.WriteString("loglevel notice\n")
	config.WriteString("logfile \"\"\n\n")

	// Database configuration
	config.WriteString("databases 16\n\n")

	// Memory configuration
	if keydbCluster.Spec.Config != nil && keydbCluster.Spec.Config.MaxMemory != "" {
		config.WriteString(fmt.Sprintf("maxmemory %s\n", keydbCluster.Spec.Config.MaxMemory))
		config.WriteString("maxmemory-policy allkeys-lru\n\n")
	}

	// Persistence configuration
	if keydbCluster.Spec.Config != nil && keydbCluster.Spec.Config.Persistence {
		config.WriteString("# Persistence\n")
		config.WriteString("save 900 1\n")
		config.WriteString("save 300 10\n")
		config.WriteString("save 60 10000\n")
		config.WriteString("stop-writes-on-bgsave-error yes\n")
		config.WriteString("rdbcompression yes\n")
		config.WriteString("rdbchecksum yes\n")
		config.WriteString("dbfilename dump.rdb\n")
		config.WriteString("dir /data\n\n")

		// AOF configuration
		config.WriteString("appendonly yes\n")
		config.WriteString("appendfilename \"appendonly.aof\"\n")
		config.WriteString("appendfsync everysec\n")
		config.WriteString("no-appendfsync-on-rewrite no\n")
		config.WriteString("auto-aof-rewrite-percentage 100\n")
		config.WriteString("auto-aof-rewrite-min-size 64mb\n\n")
	}

	// Authentication
	if keydbCluster.Spec.Config != nil && keydbCluster.Spec.Config.RequirePass != nil {
		if keydbCluster.Spec.Config.RequirePass.Value != "" {
			config.WriteString(fmt.Sprintf("requirepass %s\n", keydbCluster.Spec.Config.RequirePass.Value))
			config.WriteString(fmt.Sprintf("masterauth %s\n\n", keydbCluster.Spec.Config.RequirePass.Value))
		}
		// Note: For secret-based auth, we'd need to handle this in the container startup script
	}

	// TLS configuration
	if keydbCluster.Spec.Config != nil && keydbCluster.Spec.Config.TLS != nil && keydbCluster.Spec.Config.TLS.Enabled {
		config.WriteString("# TLS Configuration\n")
		config.WriteString("port 0\n") // Disable non-TLS port
		config.WriteString("tls-port 6380\n")
		config.WriteString("tls-cert-file /etc/keydb/tls/tls.crt\n")
		config.WriteString("tls-key-file /etc/keydb/tls/tls.key\n")
		config.WriteString("tls-ca-cert-file /etc/keydb/tls/ca.crt\n")
		config.WriteString("tls-dh-params-file /etc/keydb/tls/dh.pem\n")
		config.WriteString("tls-protocols \"TLSv1.2 TLSv1.3\"\n")
		config.WriteString("tls-ciphers \"ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256\"\n")
		config.WriteString("tls-ciphersuites \"TLS_AES_256_GCM_SHA384:TLS_AES_128_GCM_SHA256\"\n")
		config.WriteString("tls-prefer-server-ciphers yes\n")
		config.WriteString("tls-session-caching no\n")
		config.WriteString("tls-session-cache-size 5000\n")
		config.WriteString("tls-session-cache-timeout 60\n")

		if keydbCluster.Spec.Config.TLS.RequireClientCerts {
			config.WriteString("tls-auth-clients yes\n")
		}
		config.WriteString("\n")
	}

	// Mode-specific configuration
	switch keydbCluster.Spec.Mode {
	case keydbv1alpha1.MultiMasterMode:
		config.WriteString("# Multi-Master Configuration\n")
		config.WriteString("multi-master yes\n")
		if keydbCluster.Spec.MultiMaster != nil && keydbCluster.Spec.MultiMaster.ActiveReplica {
			config.WriteString("active-replica yes\n")
		}
		config.WriteString("\n")

	case keydbv1alpha1.ClusterMode:
		config.WriteString("# Cluster Configuration\n")
		config.WriteString("cluster-enabled yes\n")
		config.WriteString("cluster-config-file nodes.conf\n")
		config.WriteString("cluster-node-timeout 5000\n")
		config.WriteString("cluster-replica-validity-factor 10\n")
		config.WriteString("cluster-migration-barrier 1\n")
		config.WriteString("cluster-require-full-coverage yes\n")
		config.WriteString("cluster-allow-reads-when-down no\n\n")
	}

	// Performance tuning
	config.WriteString("# Performance\n")
	config.WriteString("tcp-keepalive 300\n")
	config.WriteString("hz 10\n\n")

	// Security
	config.WriteString("# Security\n")
	config.WriteString("protected-mode no\n") // Disabled for cluster communication
	config.WriteString("rename-command FLUSHDB \"\"\n")
	config.WriteString("rename-command FLUSHALL \"\"\n")
	config.WriteString("rename-command DEBUG \"\"\n\n")

	// Client configuration
	config.WriteString("# Client\n")
	config.WriteString("timeout 0\n")
	config.WriteString("tcp-keepalive 300\n")
	config.WriteString("maxclients 10000\n\n")

	// Custom configuration
	if keydbCluster.Spec.Config != nil && keydbCluster.Spec.Config.CustomConfig != nil {
		config.WriteString("# Custom Configuration\n")
		for key, value := range keydbCluster.Spec.Config.CustomConfig {
			config.WriteString(fmt.Sprintf("%s %s\n", key, value))
		}
		config.WriteString("\n")
	}

	return config.String()
}
